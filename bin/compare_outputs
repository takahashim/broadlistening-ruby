#!/usr/bin/env ruby
# frozen_string_literal: true

# Compare outputs between Kouchou-AI (Python) and Broadlistening gem (Ruby)
#
# Usage:
#   bin/compare_outputs python_output.json ruby_output.json
#   bin/compare_outputs --validate output.json
#   bin/compare_outputs --validate-python  # Use default Python output path

require "bundler/setup"
require "broadlistening"
require "optparse"
require "json"

options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: compare_outputs [options] [python_output] [ruby_output]"

  opts.on("-v", "--validate FILE", "Validate a single output file") do |file|
    options[:validate] = file
  end

  opts.on("--validate-python", "Validate the default Kouchou-AI Python output") do
    options[:validate_python] = true
  end

  opts.on("-s", "--schema FILE", "Validate against JSON Schema") do |file|
    options[:schema] = file
  end

  opts.on("--schema-python", "Validate Python output against JSON Schema") do
    options[:schema_python] = true
  end

  opts.on("--show-schema", "Print the JSON Schema") do
    options[:show_schema] = true
  end

  opts.on("-j", "--json", "Output in JSON format") do
    options[:json] = true
  end

  opts.on("-h", "--help", "Show this help") do
    puts opts
    exit
  end
end

parser.parse!

# Default Python output path (relative to kouchou-ai root)
PYTHON_OUTPUT_PATH = File.expand_path(
  "../../../server/broadlistening/pipeline/outputs/example-hierarchical-polis/hierarchical_result.json",
  __dir__
)

if options[:show_schema]
  puts JSON.pretty_generate(Broadlistening::Compatibility.schema)
  exit 0

elsif options[:schema]
  # Validate against JSON Schema
  file = options[:schema]
  unless File.exist?(file)
    puts "Error: File not found: #{file}"
    exit 1
  end

  errors = Broadlistening::Compatibility.validate_with_schema(file)

  if options[:json]
    puts JSON.pretty_generate({ valid: errors.empty?, errors: errors })
  else
    if errors.empty?
      puts "Schema valid: #{file}"
    else
      puts "Schema invalid: #{file}"
      puts "Errors:"
      errors.each { |e| puts "  - #{e[:path]}: #{e[:message]}" }
    end
  end

  exit(errors.empty? ? 0 : 1)

elsif options[:schema_python]
  # Validate Python output against JSON Schema
  unless File.exist?(PYTHON_OUTPUT_PATH)
    puts "Error: Python output not found at: #{PYTHON_OUTPUT_PATH}"
    exit 1
  end

  errors = Broadlistening::Compatibility.validate_with_schema(PYTHON_OUTPUT_PATH)

  if options[:json]
    puts JSON.pretty_generate({
      file: PYTHON_OUTPUT_PATH,
      valid: errors.empty?,
      errors: errors
    })
  else
    if errors.empty?
      puts "Schema valid: #{PYTHON_OUTPUT_PATH}"
    else
      puts "Schema invalid: #{PYTHON_OUTPUT_PATH}"
      puts "Errors:"
      errors.each { |e| puts "  - #{e[:path]}: #{e[:message]}" }
    end
  end

  exit(errors.empty? ? 0 : 1)

elsif options[:validate]
  # Validate single file
  file = options[:validate]
  unless File.exist?(file)
    puts "Error: File not found: #{file}"
    exit 1
  end

  output = JSON.parse(File.read(file))
  errors = Broadlistening::Compatibility.validate_output(output)

  if options[:json]
    puts JSON.pretty_generate({ valid: errors.empty?, errors: errors })
  else
    if errors.empty?
      puts "Valid: #{file}"
    else
      puts "Invalid: #{file}"
      errors.each { |e| puts "  - #{e}" }
    end
  end

  exit(errors.empty? ? 0 : 1)

elsif options[:validate_python]
  # Validate default Python output
  unless File.exist?(PYTHON_OUTPUT_PATH)
    puts "Error: Python output not found at: #{PYTHON_OUTPUT_PATH}"
    exit 1
  end

  output = JSON.parse(File.read(PYTHON_OUTPUT_PATH))
  errors = Broadlistening::Compatibility.validate_output(output)

  if options[:json]
    puts JSON.pretty_generate({
      file: PYTHON_OUTPUT_PATH,
      valid: errors.empty?,
      errors: errors
    })
  else
    if errors.empty?
      puts "Valid: #{PYTHON_OUTPUT_PATH}"
      puts ""
      puts "Stats:"
      puts "  Arguments: #{output['arguments'].size}"
      puts "  Clusters: #{output['clusters'].size}"
      puts "  Levels: #{output['clusters'].map { |c| c['level'] }.uniq.sort.join(', ')}"
      puts "  Has overview: #{!output['overview'].to_s.strip.empty?}"
    else
      puts "Invalid: #{PYTHON_OUTPUT_PATH}"
      errors.each { |e| puts "  - #{e}" }
    end
  end

  exit(errors.empty? ? 0 : 1)

elsif ARGV.size == 2
  # Compare two files
  python_file, ruby_file = ARGV

  [ python_file, ruby_file ].each do |file|
    unless File.exist?(file)
      puts "Error: File not found: #{file}"
      exit 1
    end
  end

  report = Broadlistening::Compatibility.compare_outputs(
    python_output: python_file,
    ruby_output: ruby_file
  )

  if options[:json]
    puts JSON.pretty_generate(report.to_h)
  else
    puts report.summary
  end

  exit(report.compatible? ? 0 : 1)

else
  puts parser
  exit 1
end
